
sdCard.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         000005e8  00000000  00000000  00000074  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .bss          00000030  00800060  00800060  0000065c  2**0
                  ALLOC
  2 .stab         000006cc  00000000  00000000  0000065c  2**2
                  CONTENTS, READONLY, DEBUGGING
  3 .stabstr      00000081  00000000  00000000  00000d28  2**0
                  CONTENTS, READONLY, DEBUGGING
  4 .debug_aranges 000000e0  00000000  00000000  00000da9  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_pubnames 000002c0  00000000  00000000  00000e89  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00000934  00000000  00000000  00001149  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 000004cc  00000000  00000000  00001a7d  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00000afe  00000000  00000000  00001f49  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000210  00000000  00000000  00002a48  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    000002d6  00000000  00000000  00002c58  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    0000037a  00000000  00000000  00002f2e  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_pubtypes 00000120  00000000  00000000  000032a8  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	14 c0       	rjmp	.+40     	; 0x2a <__ctors_end>
   2:	23 c0       	rjmp	.+70     	; 0x4a <__bad_interrupt>
   4:	22 c0       	rjmp	.+68     	; 0x4a <__bad_interrupt>
   6:	21 c0       	rjmp	.+66     	; 0x4a <__bad_interrupt>
   8:	20 c0       	rjmp	.+64     	; 0x4a <__bad_interrupt>
   a:	1f c0       	rjmp	.+62     	; 0x4a <__bad_interrupt>
   c:	1e c0       	rjmp	.+60     	; 0x4a <__bad_interrupt>
   e:	1d c0       	rjmp	.+58     	; 0x4a <__bad_interrupt>
  10:	1c c0       	rjmp	.+56     	; 0x4a <__bad_interrupt>
  12:	1b c0       	rjmp	.+54     	; 0x4a <__bad_interrupt>
  14:	1a c0       	rjmp	.+52     	; 0x4a <__bad_interrupt>
  16:	19 c0       	rjmp	.+50     	; 0x4a <__bad_interrupt>
  18:	18 c0       	rjmp	.+48     	; 0x4a <__bad_interrupt>
  1a:	fd c0       	rjmp	.+506    	; 0x216 <__vector_13>
  1c:	16 c0       	rjmp	.+44     	; 0x4a <__bad_interrupt>
  1e:	15 c0       	rjmp	.+42     	; 0x4a <__bad_interrupt>
  20:	14 c0       	rjmp	.+40     	; 0x4a <__bad_interrupt>
  22:	13 c0       	rjmp	.+38     	; 0x4a <__bad_interrupt>
  24:	12 c0       	rjmp	.+36     	; 0x4a <__bad_interrupt>
  26:	11 c0       	rjmp	.+34     	; 0x4a <__bad_interrupt>
  28:	10 c0       	rjmp	.+32     	; 0x4a <__bad_interrupt>

0000002a <__ctors_end>:
  2a:	11 24       	eor	r1, r1
  2c:	1f be       	out	0x3f, r1	; 63
  2e:	cf e5       	ldi	r28, 0x5F	; 95
  30:	d1 e0       	ldi	r29, 0x01	; 1
  32:	de bf       	out	0x3e, r29	; 62
  34:	cd bf       	out	0x3d, r28	; 61

00000036 <__do_clear_bss>:
  36:	10 e0       	ldi	r17, 0x00	; 0
  38:	a0 e6       	ldi	r26, 0x60	; 96
  3a:	b0 e0       	ldi	r27, 0x00	; 0
  3c:	01 c0       	rjmp	.+2      	; 0x40 <.do_clear_bss_start>

0000003e <.do_clear_bss_loop>:
  3e:	1d 92       	st	X+, r1

00000040 <.do_clear_bss_start>:
  40:	a0 39       	cpi	r26, 0x90	; 144
  42:	b1 07       	cpc	r27, r17
  44:	e1 f7       	brne	.-8      	; 0x3e <.do_clear_bss_loop>
  46:	02 d0       	rcall	.+4      	; 0x4c <main>
  48:	cd c2       	rjmp	.+1434   	; 0x5e4 <_exit>

0000004a <__bad_interrupt>:
  4a:	da cf       	rjmp	.-76     	; 0x0 <__vectors>

0000004c <main>:

#define TX_PIN PD1
#define OCR1A_PIN PB3
#define OCR1B_PIN PB4

void main() {				//start main
  4c:	ef 92       	push	r14
  4e:	ff 92       	push	r15
  50:	0f 93       	push	r16
  52:	1f 93       	push	r17
  54:	df 93       	push	r29
  56:	cf 93       	push	r28
  58:	cd b7       	in	r28, 0x3d	; 61
  5a:	de b7       	in	r29, 0x3e	; 62
  5c:	a0 97       	sbiw	r28, 0x20	; 32
  5e:	0f b6       	in	r0, 0x3f	; 63
  60:	f8 94       	cli
  62:	de bf       	out	0x3e, r29	; 62
  64:	0f be       	out	0x3f, r0	; 63
  66:	cd bf       	out	0x3d, r28	; 61

   DDRD = (1 << TX_PIN);
  68:	82 e0       	ldi	r24, 0x02	; 2
  6a:	81 bb       	out	0x11, r24	; 17
   DDRB = (1 << PB0) | (1 << OCR1A_PIN) | (1 << OCR1B_PIN);
  6c:	89 e1       	ldi	r24, 0x19	; 25
  6e:	87 bb       	out	0x17, r24	; 23
   UART_initialize();
  70:	57 d0       	rcall	.+174    	; 0x120 <UART_initialize>
   Timer1_initializeFastPwm(TURN_ON_BOTH);
  72:	82 e0       	ldi	r24, 0x02	; 2
  74:	84 d0       	rcall	.+264    	; 0x17e <Timer1_initializeFastPwm>
   Timer0_initialize();
  76:	c5 d0       	rcall	.+394    	; 0x202 <Timer0_initialize>
   SPI_initialize();
  78:	37 d1       	rcall	.+622    	; 0x2e8 <SPI_initialize>
   UART_sendByte(SD_initialize());  //0 good, -1 not good, -2 not good
  7a:	94 d1       	rcall	.+808    	; 0x3a4 <SD_initialize>
  7c:	42 d0       	rcall	.+132    	; 0x102 <UART_sendByte>
   sei();
  7e:	78 94       	sei
   uint16_t pwmVal = 1;
   uint8_t i = 0;

   uint8_t buf[32] = {0};
  80:	7e 01       	movw	r14, r28
  82:	08 94       	sec
  84:	e1 1c       	adc	r14, r1
  86:	f1 1c       	adc	r15, r1
  88:	80 e2       	ldi	r24, 0x20	; 32
  8a:	f7 01       	movw	r30, r14
  8c:	11 92       	st	Z+, r1
  8e:	8a 95       	dec	r24
  90:	e9 f7       	brne	.-6      	; 0x8c <main+0x40>
   SD_read(5, 0x55, buf, 32);
  92:	65 e0       	ldi	r22, 0x05	; 5
  94:	70 e0       	ldi	r23, 0x00	; 0
  96:	80 e0       	ldi	r24, 0x00	; 0
  98:	90 e0       	ldi	r25, 0x00	; 0
  9a:	45 e5       	ldi	r20, 0x55	; 85
  9c:	50 e0       	ldi	r21, 0x00	; 0
  9e:	97 01       	movw	r18, r14
  a0:	00 e2       	ldi	r16, 0x20	; 32
  a2:	10 e0       	ldi	r17, 0x00	; 0
  a4:	c4 d1       	rcall	.+904    	; 0x42e <SD_read>

#define TX_PIN PD1
#define OCR1A_PIN PB3
#define OCR1B_PIN PB4

void main() {				//start main
  a6:	8e 01       	movw	r16, r28
  a8:	0f 5d       	subi	r16, 0xDF	; 223
  aa:	1f 4f       	sbci	r17, 0xFF	; 255
   uint8_t i = 0;

   uint8_t buf[32] = {0};
   SD_read(5, 0x55, buf, 32);
   for (i = 0; i<32; ++i) {
      UART_sendByte(buf[i]);
  ac:	f7 01       	movw	r30, r14
  ae:	81 91       	ld	r24, Z+
  b0:	7f 01       	movw	r14, r30
  b2:	27 d0       	rcall	.+78     	; 0x102 <UART_sendByte>
   uint16_t pwmVal = 1;
   uint8_t i = 0;

   uint8_t buf[32] = {0};
   SD_read(5, 0x55, buf, 32);
   for (i = 0; i<32; ++i) {
  b4:	e0 16       	cp	r14, r16
  b6:	f1 06       	cpc	r15, r17
  b8:	c9 f7       	brne	.-14     	; 0xac <main+0x60>
  ba:	ff cf       	rjmp	.-2      	; 0xba <main+0x6e>

000000bc <UART_sendChar>:
   int i;
   for (i = 0; i < MAX_STRING_SIZE && string[i] != '\0'; ++i) UART_sendChar(string[i]);
}

void UART_sendChar(char foo) {
   while ( !(UCSRA & (1 << UDRE)) );
  bc:	5d 9b       	sbis	0x0b, 5	; 11
  be:	fe cf       	rjmp	.-4      	; 0xbc <UART_sendChar>
   UDR = foo;
  c0:	8c b9       	out	0x0c, r24	; 12
   while ( !(UCSRA & (1 << TXC)) );
  c2:	5e 9b       	sbis	0x0b, 6	; 11
  c4:	fe cf       	rjmp	.-4      	; 0xc2 <UART_sendChar+0x6>
   delay(100);
  c6:	64 e6       	ldi	r22, 0x64	; 100
  c8:	70 e0       	ldi	r23, 0x00	; 0
  ca:	80 e0       	ldi	r24, 0x00	; 0
  cc:	90 e0       	ldi	r25, 0x00	; 0
  ce:	42 d0       	rcall	.+132    	; 0x154 <delay>
}
  d0:	08 95       	ret

000000d2 <UART_sendString>:
#include "UART.h"
#include "Delay.h"
void UART_sendString(char* string) {
  d2:	0f 93       	push	r16
  d4:	1f 93       	push	r17
  d6:	cf 93       	push	r28
  d8:	df 93       	push	r29
   int i;
   for (i = 0; i < MAX_STRING_SIZE && string[i] != '\0'; ++i) UART_sendChar(string[i]);
  da:	08 2f       	mov	r16, r24
  dc:	19 2f       	mov	r17, r25
  de:	c0 e0       	ldi	r28, 0x00	; 0
  e0:	d0 e0       	ldi	r29, 0x00	; 0
  e2:	05 c0       	rjmp	.+10     	; 0xee <UART_sendString+0x1c>
  e4:	eb df       	rcall	.-42     	; 0xbc <UART_sendChar>
  e6:	21 96       	adiw	r28, 0x01	; 1
  e8:	c2 33       	cpi	r28, 0x32	; 50
  ea:	d1 05       	cpc	r29, r1
  ec:	29 f0       	breq	.+10     	; 0xf8 <UART_sendString+0x26>
  ee:	f8 01       	movw	r30, r16
  f0:	81 91       	ld	r24, Z+
  f2:	8f 01       	movw	r16, r30
  f4:	88 23       	and	r24, r24
  f6:	b1 f7       	brne	.-20     	; 0xe4 <UART_sendString+0x12>
}
  f8:	df 91       	pop	r29
  fa:	cf 91       	pop	r28
  fc:	1f 91       	pop	r17
  fe:	0f 91       	pop	r16
 100:	08 95       	ret

00000102 <UART_sendByte>:
   while ( !(UCSRA & (1 << TXC)) );
   delay(100);
}

void UART_sendByte(uint8_t foo) {
   while ( !(UCSRA & (1 << UDRE) ) );
 102:	5d 9b       	sbis	0x0b, 5	; 11
 104:	fe cf       	rjmp	.-4      	; 0x102 <UART_sendByte>
   UDR = foo;
 106:	8c b9       	out	0x0c, r24	; 12
   while ( !(UCSRA & (1 << TXC)) );
 108:	5e 9b       	sbis	0x0b, 6	; 11
 10a:	fe cf       	rjmp	.-4      	; 0x108 <UART_sendByte+0x6>
   delay(100);
 10c:	64 e6       	ldi	r22, 0x64	; 100
 10e:	70 e0       	ldi	r23, 0x00	; 0
 110:	80 e0       	ldi	r24, 0x00	; 0
 112:	90 e0       	ldi	r25, 0x00	; 0
 114:	1f d0       	rcall	.+62     	; 0x154 <delay>
}
 116:	08 95       	ret

00000118 <UART_getByte>:

uint8_t UART_getByte() {
   while ( !(UCSRA & (1 << RXC)) ); //wait for a byte to come in 
 118:	5f 9b       	sbis	0x0b, 7	; 11
 11a:	fe cf       	rjmp	.-4      	; 0x118 <UART_getByte>
   return UDR;
 11c:	8c b1       	in	r24, 0x0c	; 12
}
 11e:	08 95       	ret

00000120 <UART_initialize>:


void UART_initialize() {
//=================-USART-===========================
   UCSRA = (1 << U2X);
 120:	82 e0       	ldi	r24, 0x02	; 2
 122:	8b b9       	out	0x0b, r24	; 11
   UCSRB = (1 << TXEN) | (1 << RXEN);   //self explainatory
 124:	88 e1       	ldi	r24, 0x18	; 24
 126:	8a b9       	out	0x0a, r24	; 10
   UCSRC = (1 << UCSZ1) | (1 << UCSZ0);  //8 bit character size
 128:	86 e0       	ldi	r24, 0x06	; 6
 12a:	83 b9       	out	0x03, r24	; 3
   UBRRH = 0x01;   
 12c:	81 e0       	ldi	r24, 0x01	; 1
 12e:	82 b9       	out	0x02, r24	; 2
   UBRRL = 0xA0;  // (baud rate 2400) w/ clock @ 8MHZ   
 130:	80 ea       	ldi	r24, 0xA0	; 160
 132:	89 b9       	out	0x09, r24	; 9
//=================-SPI-=============================
   //mode0
   //DDRB = 0; nothing to be done, usually set DO as output but I'm not using DO at the moment
  // USICR =  (1 << USICS1); //enable USI timer overflow interrupt | take samples on positive edge
//=================-PIN CHANGE INTERRUPT-============
}
 134:	08 95       	ret

00000136 <delay_ms>:
#include "Delay.h"
#include "Timer0.h"

void delay_ms(uint16_t milli) {
   uint8_t sreg = SREG;   //save status reg
 136:	4f b7       	in	r20, 0x3f	; 63
   sei();
 138:	78 94       	sei
   currentMilliSeconds = 0;
 13a:	10 92 63 00 	sts	0x0063, r1
 13e:	10 92 62 00 	sts	0x0062, r1
   while(currentMilliSeconds < milli);
 142:	20 91 62 00 	lds	r18, 0x0062
 146:	30 91 63 00 	lds	r19, 0x0063
 14a:	28 17       	cp	r18, r24
 14c:	39 07       	cpc	r19, r25
 14e:	c8 f3       	brcs	.-14     	; 0x142 <delay_ms+0xc>
   SREG = sreg;
 150:	4f bf       	out	0x3f, r20	; 63
}
 152:	08 95       	ret

00000154 <delay>:

void delay(unsigned long int x)
{
 154:	9b 01       	movw	r18, r22
 156:	ac 01       	movw	r20, r24
	for (unsigned long int j=0; j<x; j++)
 158:	80 e0       	ldi	r24, 0x00	; 0
 15a:	90 e0       	ldi	r25, 0x00	; 0
 15c:	dc 01       	movw	r26, r24
 15e:	09 c0       	rjmp	.+18     	; 0x172 <__stack+0x13>
 160:	64 e6       	ldi	r22, 0x64	; 100
 162:	70 e0       	ldi	r23, 0x00	; 0
	{
		for (unsigned int i=0; i<100; i++) //137 more=better
		{
			asm("nop");
 164:	00 00       	nop
 166:	61 50       	subi	r22, 0x01	; 1
 168:	70 40       	sbci	r23, 0x00	; 0

void delay(unsigned long int x)
{
	for (unsigned long int j=0; j<x; j++)
	{
		for (unsigned int i=0; i<100; i++) //137 more=better
 16a:	e1 f7       	brne	.-8      	; 0x164 <__stack+0x5>
   SREG = sreg;
}

void delay(unsigned long int x)
{
	for (unsigned long int j=0; j<x; j++)
 16c:	01 96       	adiw	r24, 0x01	; 1
 16e:	a1 1d       	adc	r26, r1
 170:	b1 1d       	adc	r27, r1
 172:	82 17       	cp	r24, r18
 174:	93 07       	cpc	r25, r19
 176:	a4 07       	cpc	r26, r20
 178:	b5 07       	cpc	r27, r21
 17a:	90 f3       	brcs	.-28     	; 0x160 <__stack+0x1>
		for (unsigned int i=0; i<100; i++) //137 more=better
		{
			asm("nop");
		}
	}
}
 17c:	08 95       	ret

0000017e <Timer1_initializeFastPwm>:
*/

/*These functions configure Timer1 for fast pwm. the two functions configure OC1A and OC1B outputs respectively*/

void Timer1_initializeFastPwm(uint8_t WHICH_MODULE_TO_TURN_ON) {
   TCCR1A = (1 << WGM11) ; //WGM configures the waveform
 17e:	92 e0       	ldi	r25, 0x02	; 2
 180:	9f bd       	out	0x2f, r25	; 47
   TCCR1B =  (1 << WGM12) | (1 << WGM13) | (1 << CS10);  //no prescalling, the clock is the F_CPU clock
 182:	99 e1       	ldi	r25, 0x19	; 25
 184:	9e bd       	out	0x2e, r25	; 46
   ICR1 = 0xffff;
 186:	2f ef       	ldi	r18, 0xFF	; 255
 188:	3f ef       	ldi	r19, 0xFF	; 255
 18a:	35 bd       	out	0x25, r19	; 37
 18c:	24 bd       	out	0x24, r18	; 36
   switch (WHICH_MODULE_TO_TURN_ON) {
 18e:	81 30       	cpi	r24, 0x01	; 1
 190:	41 f0       	breq	.+16     	; 0x1a2 <Timer1_initializeFastPwm+0x24>
 192:	81 30       	cpi	r24, 0x01	; 1
 194:	18 f0       	brcs	.+6      	; 0x19c <Timer1_initializeFastPwm+0x1e>
 196:	82 30       	cpi	r24, 0x02	; 2
 198:	59 f4       	brne	.+22     	; 0x1b0 <Timer1_initializeFastPwm+0x32>
 19a:	07 c0       	rjmp	.+14     	; 0x1aa <Timer1_initializeFastPwm+0x2c>
      case TURN_ON_OCR1A:
         TCCR1A |= (1 << COM1A1);
 19c:	8f b5       	in	r24, 0x2f	; 47
 19e:	80 68       	ori	r24, 0x80	; 128
 1a0:	02 c0       	rjmp	.+4      	; 0x1a6 <Timer1_initializeFastPwm+0x28>
         break;
      case TURN_ON_OCR1B:
         TCCR1A |= (1 << COM1B1);
 1a2:	8f b5       	in	r24, 0x2f	; 47
 1a4:	80 62       	ori	r24, 0x20	; 32
 1a6:	8f bd       	out	0x2f, r24	; 47
         break;
 1a8:	08 95       	ret
      case TURN_ON_BOTH:
         TCCR1A |= (1 << COM1A1) | (1 << COM1B1);
 1aa:	8f b5       	in	r24, 0x2f	; 47
 1ac:	80 6a       	ori	r24, 0xA0	; 160
 1ae:	8f bd       	out	0x2f, r24	; 47
 1b0:	08 95       	ret

000001b2 <Timer1_stop>:
}

volatile uint8_t savePrescale = 0;

void Timer1_stop() {
   savePrescale = (0x07 & TCCR1B);   //save the prescale bits
 1b2:	8e b5       	in	r24, 0x2e	; 46
 1b4:	87 70       	andi	r24, 0x07	; 7
 1b6:	80 93 60 00 	sts	0x0060, r24
   TCCR1B &= 0xf8;   //clear the prescale to stop the timer
 1ba:	8e b5       	in	r24, 0x2e	; 46
 1bc:	88 7f       	andi	r24, 0xF8	; 248
 1be:	8e bd       	out	0x2e, r24	; 46
}
 1c0:	08 95       	ret

000001c2 <Timer1_start>:

void Timer1_start() {
   TCCR1B |= savePrescale;
 1c2:	9e b5       	in	r25, 0x2e	; 46
 1c4:	80 91 60 00 	lds	r24, 0x0060
 1c8:	89 2b       	or	r24, r25
 1ca:	8e bd       	out	0x2e, r24	; 46
}
 1cc:	08 95       	ret

000001ce <Timer1_getValue>:
   cli();
   uint16_t value = TCNT1L;   //temp register get updated with TCNT1H after this executes
            value |= TCNT1H << 8;
   SREG = sreg;
*/
   return   TCNT1;
 1ce:	2c b5       	in	r18, 0x2c	; 44
 1d0:	3d b5       	in	r19, 0x2d	; 45
}
 1d2:	c9 01       	movw	r24, r18
 1d4:	08 95       	ret

000001d6 <Timer1_setOCR1A>:
   cli();
   OCR1AH = value >> 8;
   OCR1AL = (uint8_t) value; 
   SREG = sreg;
*/
   OCR1A = value;
 1d6:	9b bd       	out	0x2b, r25	; 43
 1d8:	8a bd       	out	0x2a, r24	; 42
}
 1da:	08 95       	ret

000001dc <Timer1_setOCR1B>:
   cli();
   OCR1BH = value >> 8;
   OCR1BL = (uint8_t) value; 
   SREG = sreg;
*/
   OCR1B = value;
 1dc:	99 bd       	out	0x29, r25	; 41
 1de:	88 bd       	out	0x28, r24	; 40
}
 1e0:	08 95       	ret

000001e2 <Timer0_stop>:

/*Configure Timer 1 ISR to fire every 1ms, This can be used for a System time, and in 10ms I need to call an Timer process function in diskio.c.*/

volatile uint8_t prescale = 0;
void Timer0_stop() {
   prescale = TCCR0B & 0x07;
 1e2:	83 b7       	in	r24, 0x33	; 51
 1e4:	87 70       	andi	r24, 0x07	; 7
 1e6:	80 93 61 00 	sts	0x0061, r24
   TCCR0B &= 0xf8;
 1ea:	83 b7       	in	r24, 0x33	; 51
 1ec:	88 7f       	andi	r24, 0xF8	; 248
 1ee:	83 bf       	out	0x33, r24	; 51
}
 1f0:	08 95       	ret

000001f2 <Timer0_start>:

void Timer0_start() {
   TCCR0B |= prescale;
 1f2:	93 b7       	in	r25, 0x33	; 51
 1f4:	80 91 61 00 	lds	r24, 0x0061
 1f8:	89 2b       	or	r24, r25
 1fa:	83 bf       	out	0x33, r24	; 51
}
 1fc:	08 95       	ret

000001fe <Timer0_reset>:

void Timer0_reset() {
   TCNT0 = 0x00;
 1fe:	12 be       	out	0x32, r1	; 50
}
 200:	08 95       	ret

00000202 <Timer0_initialize>:

void Timer0_initialize(void) {
   TCCR0A = (1 << WGM01);   //CTC mode
 202:	82 e0       	ldi	r24, 0x02	; 2
 204:	80 bf       	out	0x30, r24	; 48
   //TCCR0B gets configured in configRegistersForThisPeriod(period)
   /*setting OCR0A to 181 and prescale of 1 configures the timer to interrupt 44.1kHz which is the audio play back frequency of CD's*/
   /* counding 441 of the interrupts = 10 ms of time*/
   OCR0A = 181;  
 206:	85 eb       	ldi	r24, 0xB5	; 181
 208:	86 bf       	out	0x36, r24	; 54
   TCCR0B = (1 << CS00); 
 20a:	81 e0       	ldi	r24, 0x01	; 1
 20c:	83 bf       	out	0x33, r24	; 51
   TIMSK |= (1 << OCIE0A);   
 20e:	89 b7       	in	r24, 0x39	; 57
 210:	81 60       	ori	r24, 0x01	; 1
 212:	89 bf       	out	0x39, r24	; 57
}
 214:	08 95       	ret

00000216 <__vector_13>:

volatile uint16_t currentMilliSeconds = 0;
volatile uint32_t currentSeconds = 0;
volatile uint16_t interruptCounter = 0;

ISR (TIMER0_COMPA_vect) {  
 216:	1f 92       	push	r1
 218:	0f 92       	push	r0
 21a:	0f b6       	in	r0, 0x3f	; 63
 21c:	0f 92       	push	r0
 21e:	11 24       	eor	r1, r1
 220:	2f 93       	push	r18
 222:	8f 93       	push	r24
 224:	9f 93       	push	r25
 226:	af 93       	push	r26
 228:	bf 93       	push	r27
   ++interruptCounter;
 22a:	80 91 68 00 	lds	r24, 0x0068
 22e:	90 91 69 00 	lds	r25, 0x0069
 232:	01 96       	adiw	r24, 0x01	; 1
 234:	90 93 69 00 	sts	0x0069, r25
 238:	80 93 68 00 	sts	0x0068, r24
   /*Play back code in here that executes 44.1kHz 

   */ 
   if (interruptCounter >= 441) {
 23c:	80 91 68 00 	lds	r24, 0x0068
 240:	90 91 69 00 	lds	r25, 0x0069
 244:	21 e0       	ldi	r18, 0x01	; 1
 246:	89 3b       	cpi	r24, 0xB9	; 185
 248:	92 07       	cpc	r25, r18
 24a:	68 f0       	brcs	.+26     	; 0x266 <__vector_13+0x50>
      interruptCounter = 0;
 24c:	10 92 69 00 	sts	0x0069, r1
 250:	10 92 68 00 	sts	0x0068, r1
      currentMilliSeconds += 10;
 254:	80 91 62 00 	lds	r24, 0x0062
 258:	90 91 63 00 	lds	r25, 0x0063
 25c:	0a 96       	adiw	r24, 0x0a	; 10
 25e:	90 93 63 00 	sts	0x0063, r25
 262:	80 93 62 00 	sts	0x0062, r24
   }
   if (currentMilliSeconds >= 1000) {
 266:	80 91 62 00 	lds	r24, 0x0062
 26a:	90 91 63 00 	lds	r25, 0x0063
 26e:	23 e0       	ldi	r18, 0x03	; 3
 270:	88 3e       	cpi	r24, 0xE8	; 232
 272:	92 07       	cpc	r25, r18
 274:	b8 f0       	brcs	.+46     	; 0x2a4 <__vector_13+0x8e>
      currentMilliSeconds = 0;
 276:	10 92 63 00 	sts	0x0063, r1
 27a:	10 92 62 00 	sts	0x0062, r1
      ++currentSeconds;
 27e:	80 91 64 00 	lds	r24, 0x0064
 282:	90 91 65 00 	lds	r25, 0x0065
 286:	a0 91 66 00 	lds	r26, 0x0066
 28a:	b0 91 67 00 	lds	r27, 0x0067
 28e:	01 96       	adiw	r24, 0x01	; 1
 290:	a1 1d       	adc	r26, r1
 292:	b1 1d       	adc	r27, r1
 294:	80 93 64 00 	sts	0x0064, r24
 298:	90 93 65 00 	sts	0x0065, r25
 29c:	a0 93 66 00 	sts	0x0066, r26
 2a0:	b0 93 67 00 	sts	0x0067, r27
   }
   if (currentSeconds >= 1) {
 2a4:	80 91 64 00 	lds	r24, 0x0064
 2a8:	90 91 65 00 	lds	r25, 0x0065
 2ac:	a0 91 66 00 	lds	r26, 0x0066
 2b0:	b0 91 67 00 	lds	r27, 0x0067
 2b4:	00 97       	sbiw	r24, 0x00	; 0
 2b6:	a1 05       	cpc	r26, r1
 2b8:	b1 05       	cpc	r27, r1
 2ba:	61 f0       	breq	.+24     	; 0x2d4 <__vector_13+0xbe>
      currentSeconds = 0;
 2bc:	10 92 64 00 	sts	0x0064, r1
 2c0:	10 92 65 00 	sts	0x0065, r1
 2c4:	10 92 66 00 	sts	0x0066, r1
 2c8:	10 92 67 00 	sts	0x0067, r1
      PORTB ^= (1 << PB0);
 2cc:	88 b3       	in	r24, 0x18	; 24
 2ce:	91 e0       	ldi	r25, 0x01	; 1
 2d0:	89 27       	eor	r24, r25
 2d2:	88 bb       	out	0x18, r24	; 24
   }
}
 2d4:	bf 91       	pop	r27
 2d6:	af 91       	pop	r26
 2d8:	9f 91       	pop	r25
 2da:	8f 91       	pop	r24
 2dc:	2f 91       	pop	r18
 2de:	0f 90       	pop	r0
 2e0:	0f be       	out	0x3f, r0	; 63
 2e2:	0f 90       	pop	r0
 2e4:	1f 90       	pop	r1
 2e6:	18 95       	reti

000002e8 <SPI_initialize>:
#define MOSI PB6
#define SCK  PB7
#define CS PD6

void SPI_initialize(void) {
   PORTB |= (1 << SCK) | (1 << MOSI);	//Configure SCK/MOSI/CS as output 
 2e8:	88 b3       	in	r24, 0x18	; 24
 2ea:	80 6c       	ori	r24, 0xC0	; 192
 2ec:	88 bb       	out	0x18, r24	; 24
   CS_HIGH();
 2ee:	96 9a       	sbi	0x12, 6	; 18
   DDRB  |= (1 << SCK) | (1 << MOSI);
 2f0:	87 b3       	in	r24, 0x17	; 23
 2f2:	80 6c       	ori	r24, 0xC0	; 192
 2f4:	87 bb       	out	0x17, r24	; 23
   DDRB  &= ~(1 << MISO);   //MISO is input
 2f6:	bd 98       	cbi	0x17, 5	; 23
   DDRD  |= (1 << PD6);
 2f8:	8e 9a       	sbi	0x11, 6	; 17
   USICR = (1 << USIWM0) | (1 << USICS1);   //spi mode | clock source is positive edge using USCK pin
 2fa:	88 e1       	ldi	r24, 0x18	; 24
 2fc:	8d b9       	out	0x0d, r24	; 13
}
 2fe:	08 95       	ret

00000300 <SPI_send>:

uint8_t SPI_send(uint8_t data) {
 300:	cf 93       	push	r28
 302:	df 93       	push	r29
   uint8_t i,j;
   uint8_t sreg = SREG;   //save status reg
 304:	df b7       	in	r29, 0x3f	; 63
   cli();
 306:	f8 94       	cli
   USISR &= 0xf0; //clear the counter
 308:	9e b1       	in	r25, 0x0e	; 14
 30a:	90 7f       	andi	r25, 0xF0	; 240
 30c:	9e b9       	out	0x0e, r25	; 14
   PORTB &= ~(1 << SCK); //clear the clock line
 30e:	c7 98       	cbi	0x18, 7	; 24
   USIDR = data;
 310:	8f b9       	out	0x0f, r24	; 15
   uint8_t foo = USICR | (1 << USITC);
 312:	cd b1       	in	r28, 0x0d	; 13
 314:	c1 60       	ori	r28, 0x01	; 1
   CS_LOW();
 316:	96 98       	cbi	0x12, 6	; 18
   delay(1);
 318:	61 e0       	ldi	r22, 0x01	; 1
 31a:	70 e0       	ldi	r23, 0x00	; 0
 31c:	80 e0       	ldi	r24, 0x00	; 0
 31e:	90 e0       	ldi	r25, 0x00	; 0
 320:	19 df       	rcall	.-462    	; 0x154 <delay>
 322:	80 e1       	ldi	r24, 0x10	; 16
   for (i = 0; i < 16; ++i) {
         USICR = foo;
 324:	cd b9       	out	0x0d, r28	; 13
 326:	81 50       	subi	r24, 0x01	; 1
   PORTB &= ~(1 << SCK); //clear the clock line
   USIDR = data;
   uint8_t foo = USICR | (1 << USITC);
   CS_LOW();
   delay(1);
   for (i = 0; i < 16; ++i) {
 328:	e9 f7       	brne	.-6      	; 0x324 <SPI_send+0x24>
         USICR = foo;
   } 
   CS_HIGH();
 32a:	96 9a       	sbi	0x12, 6	; 18
   SREG = sreg;
 32c:	df bf       	out	0x3f, r29	; 63
   return USIDR;
 32e:	8f b1       	in	r24, 0x0f	; 15
}
 330:	df 91       	pop	r29
 332:	cf 91       	pop	r28
 334:	08 95       	ret

00000336 <SD_command>:

#define CARD_READY 0
#define CARD_BUSY 1

uint8_t SD_command(uint8_t cmd, uint32_t arg, 
                uint8_t crc, uint8_t read) {
 336:	0f 93       	push	r16
 338:	1f 93       	push	r17
 33a:	df 93       	push	r29
 33c:	cf 93       	push	r28
 33e:	00 d0       	rcall	.+0      	; 0x340 <SD_command+0xa>
 340:	00 d0       	rcall	.+0      	; 0x342 <SD_command+0xc>
 342:	0f 92       	push	r0
 344:	cd b7       	in	r28, 0x3d	; 61
 346:	de b7       	in	r29, 0x3e	; 62
        
    CS_LOW();
 348:	96 98       	cbi	0x12, 6	; 18
    SPI_send(cmd);
 34a:	2d 83       	std	Y+5, r18	; 0x05
 34c:	4c 83       	std	Y+4, r20	; 0x04
 34e:	5b 83       	std	Y+3, r21	; 0x03
 350:	6a 83       	std	Y+2, r22	; 0x02
 352:	79 83       	std	Y+1, r23	; 0x01
 354:	d5 df       	rcall	.-86     	; 0x300 <SPI_send>
    SPI_send(arg>>24);
 356:	79 81       	ldd	r23, Y+1	; 0x01
 358:	87 2f       	mov	r24, r23
 35a:	d2 df       	rcall	.-92     	; 0x300 <SPI_send>
    SPI_send(arg>>16);
 35c:	6a 81       	ldd	r22, Y+2	; 0x02
 35e:	86 2f       	mov	r24, r22
 360:	cf df       	rcall	.-98     	; 0x300 <SPI_send>
    SPI_send(arg>>8);
 362:	5b 81       	ldd	r21, Y+3	; 0x03
 364:	85 2f       	mov	r24, r21
 366:	cc df       	rcall	.-104    	; 0x300 <SPI_send>
    SPI_send(arg);
 368:	4c 81       	ldd	r20, Y+4	; 0x04
 36a:	84 2f       	mov	r24, r20
 36c:	c9 df       	rcall	.-110    	; 0x300 <SPI_send>
    SPI_send(crc);
 36e:	2d 81       	ldd	r18, Y+5	; 0x05
 370:	82 2f       	mov	r24, r18
 372:	c6 df       	rcall	.-116    	; 0x300 <SPI_send>
    uint8_t i;      
    for(i=0; i<read; i++) {
 374:	10 e0       	ldi	r17, 0x00	; 0
 376:	08 c0       	rjmp	.+16     	; 0x388 <SD_command+0x52>
         if (0x01 == SPI_send(0xFF) ) { //card sent back a 1 == ready 
 378:	8f ef       	ldi	r24, 0xFF	; 255
 37a:	c2 df       	rcall	.-124    	; 0x300 <SPI_send>
 37c:	81 30       	cpi	r24, 0x01	; 1
 37e:	19 f4       	brne	.+6      	; 0x386 <SD_command+0x50>
            CS_HIGH();
 380:	96 9a       	sbi	0x12, 6	; 18
            return CARD_READY;
 382:	80 e0       	ldi	r24, 0x00	; 0
 384:	05 c0       	rjmp	.+10     	; 0x390 <SD_command+0x5a>
    SPI_send(arg>>16);
    SPI_send(arg>>8);
    SPI_send(arg);
    SPI_send(crc);
    uint8_t i;      
    for(i=0; i<read; i++) {
 386:	1f 5f       	subi	r17, 0xFF	; 255
 388:	10 17       	cp	r17, r16
 38a:	b0 f3       	brcs	.-20     	; 0x378 <SD_command+0x42>
         if (0x01 == SPI_send(0xFF) ) { //card sent back a 1 == ready 
            CS_HIGH();
            return CARD_READY;
         }
    }
    CS_HIGH();    
 38c:	96 9a       	sbi	0x12, 6	; 18
    return CARD_BUSY;           
 38e:	81 e0       	ldi	r24, 0x01	; 1
}
 390:	0f 90       	pop	r0
 392:	0f 90       	pop	r0
 394:	0f 90       	pop	r0
 396:	0f 90       	pop	r0
 398:	0f 90       	pop	r0
 39a:	cf 91       	pop	r28
 39c:	df 91       	pop	r29
 39e:	1f 91       	pop	r17
 3a0:	0f 91       	pop	r16
 3a2:	08 95       	ret

000003a4 <SD_initialize>:


unsigned long sd_sector;
unsigned short sd_pos;

char SD_initialize(void) {
 3a4:	0f 93       	push	r16
 3a6:	cf 93       	push	r28
    char i;
    cli();
 3a8:	f8 94       	cli
    // ]r:10
    CS_HIGH();
 3aa:	96 9a       	sbi	0x12, 6	; 18
 3ac:	ca e0       	ldi	r28, 0x0A	; 10
    for(i=0; i<10; i++) // idle for 1 bytes / 80 clocks
        SPI_send(0xFF);
 3ae:	8f ef       	ldi	r24, 0xFF	; 255
 3b0:	a7 df       	rcall	.-178    	; 0x300 <SPI_send>
 3b2:	c1 50       	subi	r28, 0x01	; 1
char SD_initialize(void) {
    char i;
    cli();
    // ]r:10
    CS_HIGH();
    for(i=0; i<10; i++) // idle for 1 bytes / 80 clocks
 3b4:	e1 f7       	brne	.-8      	; 0x3ae <SD_initialize+0xa>
 3b6:	08 c0       	rjmp	.+16     	; 0x3c8 <SD_initialize+0x24>
        SPI_send(0xFF);
                
    // [0x40 0x00 0x00 0x00 0x00 0x95 r:8] until we get "1"
    for(i=0; i<10 && SD_command(0x40, 0x00000000, 0x95, 8) != 1; i++) {
       delay_ms(100);
 3b8:	84 e6       	ldi	r24, 0x64	; 100
 3ba:	90 e0       	ldi	r25, 0x00	; 0
 3bc:	bc de       	rcall	.-648    	; 0x136 <delay_ms>
    CS_HIGH();
    for(i=0; i<10; i++) // idle for 1 bytes / 80 clocks
        SPI_send(0xFF);
                
    // [0x40 0x00 0x00 0x00 0x00 0x95 r:8] until we get "1"
    for(i=0; i<10 && SD_command(0x40, 0x00000000, 0x95, 8) != 1; i++) {
 3be:	cf 5f       	subi	r28, 0xFF	; 255
 3c0:	ca 30       	cpi	r28, 0x0A	; 10
 3c2:	11 f4       	brne	.+4      	; 0x3c8 <SD_initialize+0x24>
       delay_ms(100);
    }
    if(i == 10) // card did not respond to initialization
        return CARD_NOT_INIT;
 3c4:	8f ef       	ldi	r24, 0xFF	; 255
 3c6:	30 c0       	rjmp	.+96     	; 0x428 <SD_initialize+0x84>
    CS_HIGH();
    for(i=0; i<10; i++) // idle for 1 bytes / 80 clocks
        SPI_send(0xFF);
                
    // [0x40 0x00 0x00 0x00 0x00 0x95 r:8] until we get "1"
    for(i=0; i<10 && SD_command(0x40, 0x00000000, 0x95, 8) != 1; i++) {
 3c8:	80 e4       	ldi	r24, 0x40	; 64
 3ca:	40 e0       	ldi	r20, 0x00	; 0
 3cc:	50 e0       	ldi	r21, 0x00	; 0
 3ce:	ba 01       	movw	r22, r20
 3d0:	25 e9       	ldi	r18, 0x95	; 149
 3d2:	08 e0       	ldi	r16, 0x08	; 8
 3d4:	b0 df       	rcall	.-160    	; 0x336 <SD_command>
 3d6:	81 30       	cpi	r24, 0x01	; 1
 3d8:	79 f7       	brne	.-34     	; 0x3b8 <SD_initialize+0x14>
 3da:	c0 e0       	ldi	r28, 0x00	; 0
 3dc:	08 c0       	rjmp	.+16     	; 0x3ee <SD_initialize+0x4a>
    if(i == 10) // card did not respond to initialization
        return CARD_NOT_INIT;
                
    // CMD1 until card comes out of idle, but maximum of 10 times
    for(i=0; i<10 && SD_command(0x41, 0x00000000, 0xFF, 8) != 0; i++) {
       delay_ms(100);
 3de:	84 e6       	ldi	r24, 0x64	; 100
 3e0:	90 e0       	ldi	r25, 0x00	; 0
 3e2:	a9 de       	rcall	.-686    	; 0x136 <delay_ms>
    }
    if(i == 10) // card did not respond to initialization
        return CARD_NOT_INIT;
                
    // CMD1 until card comes out of idle, but maximum of 10 times
    for(i=0; i<10 && SD_command(0x41, 0x00000000, 0xFF, 8) != 0; i++) {
 3e4:	cf 5f       	subi	r28, 0xFF	; 255
 3e6:	ca 30       	cpi	r28, 0x0A	; 10
 3e8:	11 f4       	brne	.+4      	; 0x3ee <SD_initialize+0x4a>
       delay_ms(100);
    }

    if(i == 10) // card did not come out of idle
        return CARD_IN_IDLE;
 3ea:	8e ef       	ldi	r24, 0xFE	; 254
 3ec:	1d c0       	rjmp	.+58     	; 0x428 <SD_initialize+0x84>
    }
    if(i == 10) // card did not respond to initialization
        return CARD_NOT_INIT;
                
    // CMD1 until card comes out of idle, but maximum of 10 times
    for(i=0; i<10 && SD_command(0x41, 0x00000000, 0xFF, 8) != 0; i++) {
 3ee:	81 e4       	ldi	r24, 0x41	; 65
 3f0:	40 e0       	ldi	r20, 0x00	; 0
 3f2:	50 e0       	ldi	r21, 0x00	; 0
 3f4:	ba 01       	movw	r22, r20
 3f6:	2f ef       	ldi	r18, 0xFF	; 255
 3f8:	08 e0       	ldi	r16, 0x08	; 8
 3fa:	9d df       	rcall	.-198    	; 0x336 <SD_command>
 3fc:	88 23       	and	r24, r24
 3fe:	79 f7       	brne	.-34     	; 0x3de <SD_initialize+0x3a>

    if(i == 10) // card did not come out of idle
        return CARD_IN_IDLE;
                
    // SET_BLOCKLEN to 512
    SD_command(0x50, 0x00000200, 0xFF, 8);
 400:	80 e5       	ldi	r24, 0x50	; 80
 402:	40 e0       	ldi	r20, 0x00	; 0
 404:	52 e0       	ldi	r21, 0x02	; 2
 406:	60 e0       	ldi	r22, 0x00	; 0
 408:	70 e0       	ldi	r23, 0x00	; 0
 40a:	2f ef       	ldi	r18, 0xFF	; 255
 40c:	94 df       	rcall	.-216    	; 0x336 <SD_command>
        
    sd_sector = sd_pos = 0;
 40e:	10 92 8f 00 	sts	0x008F, r1
 412:	10 92 8e 00 	sts	0x008E, r1
 416:	10 92 6a 00 	sts	0x006A, r1
 41a:	10 92 6b 00 	sts	0x006B, r1
 41e:	10 92 6c 00 	sts	0x006C, r1
 422:	10 92 6d 00 	sts	0x006D, r1
        
    return CARD_INIT;
 426:	80 e0       	ldi	r24, 0x00	; 0
}
 428:	cf 91       	pop	r28
 42a:	0f 91       	pop	r16
 42c:	08 95       	ret

0000042e <SD_read>:

// TODO: This function will not exit gracefully if SD card does not do what it should
void SD_read(unsigned long sector, unsigned short offset, unsigned char * buffer, 
             unsigned short len) {
 42e:	af 92       	push	r10
 430:	bf 92       	push	r11
 432:	cf 92       	push	r12
 434:	df 92       	push	r13
 436:	ef 92       	push	r14
 438:	ff 92       	push	r15
 43a:	0f 93       	push	r16
 43c:	1f 93       	push	r17
 43e:	cf 93       	push	r28
 440:	df 93       	push	r29
 442:	6b 01       	movw	r12, r22
 444:	7c 01       	movw	r14, r24
 446:	5a 01       	movw	r10, r20
 448:	d2 2f       	mov	r29, r18
 44a:	c3 2f       	mov	r28, r19
    unsigned short i, pos = 0;
    
    CS_LOW();
 44c:	96 98       	cbi	0x12, 6	; 18
    SPI_send(0x51);       // sector * 512 = sector << 9 
 44e:	81 e5       	ldi	r24, 0x51	; 81
 450:	57 df       	rcall	.-338    	; 0x300 <SPI_send>
    SPI_send(sector>>15); // sector*512 >> 24  
 452:	d7 01       	movw	r26, r14
 454:	c6 01       	movw	r24, r12
 456:	3f e0       	ldi	r19, 0x0F	; 15
 458:	b6 95       	lsr	r27
 45a:	a7 95       	ror	r26
 45c:	97 95       	ror	r25
 45e:	87 95       	ror	r24
 460:	3a 95       	dec	r19
 462:	d1 f7       	brne	.-12     	; 0x458 <SD_read+0x2a>
 464:	4d df       	rcall	.-358    	; 0x300 <SPI_send>
    SPI_send(sector>>7);  // sector*512 >> 16
 466:	d7 01       	movw	r26, r14
 468:	c6 01       	movw	r24, r12
 46a:	27 e0       	ldi	r18, 0x07	; 7
 46c:	b6 95       	lsr	r27
 46e:	a7 95       	ror	r26
 470:	97 95       	ror	r25
 472:	87 95       	ror	r24
 474:	2a 95       	dec	r18
 476:	d1 f7       	brne	.-12     	; 0x46c <SD_read+0x3e>
 478:	43 df       	rcall	.-378    	; 0x300 <SPI_send>
    SPI_send(sector<<1);  // sector*512 >> 8
 47a:	8c 2d       	mov	r24, r12
 47c:	88 0f       	add	r24, r24
 47e:	40 df       	rcall	.-384    	; 0x300 <SPI_send>
    SPI_send(0);          // sector*512
 480:	80 e0       	ldi	r24, 0x00	; 0
 482:	3e df       	rcall	.-388    	; 0x300 <SPI_send>
    SPI_send(0xFF);
 484:	8f ef       	ldi	r24, 0xFF	; 255
 486:	3c df       	rcall	.-392    	; 0x300 <SPI_send>
 488:	9a e0       	ldi	r25, 0x0A	; 10
 48a:	c9 2e       	mov	r12, r25
 48c:	d1 2c       	mov	r13, r1
 48e:	06 c0       	rjmp	.+12     	; 0x49c <SD_read+0x6e>
 490:	08 94       	sec
 492:	c1 08       	sbc	r12, r1
 494:	d1 08       	sbc	r13, r1
    
    for(i=0; i<10 && SPI_send(0xFF) != 0x00; i++) {} // wait for 0
 496:	c1 14       	cp	r12, r1
 498:	d1 04       	cpc	r13, r1
 49a:	61 f0       	breq	.+24     	; 0x4b4 <SD_read+0x86>
 49c:	8f ef       	ldi	r24, 0xFF	; 255
 49e:	30 df       	rcall	.-416    	; 0x300 <SPI_send>
 4a0:	88 23       	and	r24, r24
 4a2:	b1 f7       	brne	.-20     	; 0x490 <SD_read+0x62>
 4a4:	07 c0       	rjmp	.+14     	; 0x4b4 <SD_read+0x86>
 4a6:	08 94       	sec
 4a8:	c1 08       	sbc	r12, r1
 4aa:	d1 08       	sbc	r13, r1
    
    for(i=0; i<10 && SPI_send(0xFF) != 0xFE; i++) {} // wait for data start
 4ac:	c1 14       	cp	r12, r1
 4ae:	d1 04       	cpc	r13, r1
 4b0:	21 f4       	brne	.+8      	; 0x4ba <SD_read+0x8c>
 4b2:	0e c0       	rjmp	.+28     	; 0x4d0 <SD_read+0xa2>
    SPI_send(sector>>7);  // sector*512 >> 16
    SPI_send(sector<<1);  // sector*512 >> 8
    SPI_send(0);          // sector*512
    SPI_send(0xFF);
    
    for(i=0; i<10 && SPI_send(0xFF) != 0x00; i++) {} // wait for 0
 4b4:	8a e0       	ldi	r24, 0x0A	; 10
 4b6:	c8 2e       	mov	r12, r24
 4b8:	d1 2c       	mov	r13, r1
    
    for(i=0; i<10 && SPI_send(0xFF) != 0xFE; i++) {} // wait for data start
 4ba:	8f ef       	ldi	r24, 0xFF	; 255
 4bc:	21 df       	rcall	.-446    	; 0x300 <SPI_send>
 4be:	8e 3f       	cpi	r24, 0xFE	; 254
 4c0:	91 f7       	brne	.-28     	; 0x4a6 <SD_read+0x78>
 4c2:	06 c0       	rjmp	.+12     	; 0x4d0 <SD_read+0xa2>
    
    for(i=0; i<offset; i++) // "skip" bytes
        SPI_send(0xFF);
 4c4:	8f ef       	ldi	r24, 0xFF	; 255
 4c6:	1c df       	rcall	.-456    	; 0x300 <SPI_send>
    
    for(i=0; i<10 && SPI_send(0xFF) != 0x00; i++) {} // wait for 0
    
    for(i=0; i<10 && SPI_send(0xFF) != 0xFE; i++) {} // wait for data start
    
    for(i=0; i<offset; i++) // "skip" bytes
 4c8:	08 94       	sec
 4ca:	c1 1c       	adc	r12, r1
 4cc:	d1 1c       	adc	r13, r1
 4ce:	02 c0       	rjmp	.+4      	; 0x4d4 <SD_read+0xa6>
    SPI_send(0);          // sector*512
    SPI_send(0xFF);
    
    for(i=0; i<10 && SPI_send(0xFF) != 0x00; i++) {} // wait for 0
    
    for(i=0; i<10 && SPI_send(0xFF) != 0xFE; i++) {} // wait for data start
 4d0:	cc 24       	eor	r12, r12
 4d2:	dd 24       	eor	r13, r13
    
    for(i=0; i<offset; i++) // "skip" bytes
 4d4:	ca 14       	cp	r12, r10
 4d6:	db 04       	cpc	r13, r11
 4d8:	a8 f3       	brcs	.-22     	; 0x4c4 <SD_read+0x96>
 4da:	ce 01       	movw	r24, r28
 4dc:	c9 2e       	mov	r12, r25
 4de:	dc 2e       	mov	r13, r28
 4e0:	c0 e0       	ldi	r28, 0x00	; 0
 4e2:	d0 e0       	ldi	r29, 0x00	; 0
 4e4:	06 c0       	rjmp	.+12     	; 0x4f2 <SD_read+0xc4>
        SPI_send(0xFF);
        
    for(i=0; i<len; i++) // read len bytes
        buffer[i] = SPI_send(0xFF);
 4e6:	8f ef       	ldi	r24, 0xFF	; 255
 4e8:	0b df       	rcall	.-490    	; 0x300 <SPI_send>
 4ea:	f6 01       	movw	r30, r12
 4ec:	81 93       	st	Z+, r24
 4ee:	6f 01       	movw	r12, r30
    for(i=0; i<10 && SPI_send(0xFF) != 0xFE; i++) {} // wait for data start
    
    for(i=0; i<offset; i++) // "skip" bytes
        SPI_send(0xFF);
        
    for(i=0; i<len; i++) // read len bytes
 4f0:	21 96       	adiw	r28, 0x01	; 1
 4f2:	c0 17       	cp	r28, r16
 4f4:	d1 07       	cpc	r29, r17
 4f6:	b8 f3       	brcs	.-18     	; 0x4e6 <SD_read+0xb8>
        buffer[i] = SPI_send(0xFF);
        
    for(i+=offset; i<512; i++) // "skip" again
 4f8:	0a 0d       	add	r16, r10
 4fa:	1b 1d       	adc	r17, r11
 4fc:	04 c0       	rjmp	.+8      	; 0x506 <SD_read+0xd8>
        SPI_send(0xFF);
 4fe:	8f ef       	ldi	r24, 0xFF	; 255
 500:	ff de       	rcall	.-514    	; 0x300 <SPI_send>
        SPI_send(0xFF);
        
    for(i=0; i<len; i++) // read len bytes
        buffer[i] = SPI_send(0xFF);
        
    for(i+=offset; i<512; i++) // "skip" again
 502:	0f 5f       	subi	r16, 0xFF	; 255
 504:	1f 4f       	sbci	r17, 0xFF	; 255
 506:	f2 e0       	ldi	r31, 0x02	; 2
 508:	00 30       	cpi	r16, 0x00	; 0
 50a:	1f 07       	cpc	r17, r31
 50c:	c0 f3       	brcs	.-16     	; 0x4fe <SD_read+0xd0>
        SPI_send(0xFF);
        
    // skip checksum
    SPI_send(0xFF);
 50e:	8f ef       	ldi	r24, 0xFF	; 255
 510:	f7 de       	rcall	.-530    	; 0x300 <SPI_send>
    SPI_send(0xFF);    
 512:	8f ef       	ldi	r24, 0xFF	; 255
 514:	f5 de       	rcall	.-534    	; 0x300 <SPI_send>

    CS_HIGH();    
 516:	96 9a       	sbi	0x12, 6	; 18
}
 518:	df 91       	pop	r29
 51a:	cf 91       	pop	r28
 51c:	1f 91       	pop	r17
 51e:	0f 91       	pop	r16
 520:	ff 90       	pop	r15
 522:	ef 90       	pop	r14
 524:	df 90       	pop	r13
 526:	cf 90       	pop	r12
 528:	bf 90       	pop	r11
 52a:	af 90       	pop	r10
 52c:	08 95       	ret

0000052e <fat16_seek>:

char fat16_buffer[32];

void fat16_seek(unsigned long offset) {
    sd_sector = offset >> 9;
 52e:	9b 01       	movw	r18, r22
 530:	ac 01       	movw	r20, r24
 532:	e9 e0       	ldi	r30, 0x09	; 9
 534:	56 95       	lsr	r21
 536:	47 95       	ror	r20
 538:	37 95       	ror	r19
 53a:	27 95       	ror	r18
 53c:	ea 95       	dec	r30
 53e:	d1 f7       	brne	.-12     	; 0x534 <fat16_seek+0x6>
 540:	20 93 6a 00 	sts	0x006A, r18
 544:	30 93 6b 00 	sts	0x006B, r19
 548:	40 93 6c 00 	sts	0x006C, r20
 54c:	50 93 6d 00 	sts	0x006D, r21
    sd_pos = offset & 511;        
 550:	71 70       	andi	r23, 0x01	; 1
 552:	70 93 8f 00 	sts	0x008F, r23
 556:	60 93 8e 00 	sts	0x008E, r22
}
 55a:	08 95       	ret

0000055c <fat16_read>:

char fat16_read(unsigned char bytes) {
 55c:	ef 92       	push	r14
 55e:	ff 92       	push	r15
 560:	0f 93       	push	r16
 562:	1f 93       	push	r17
 564:	cf 93       	push	r28
 566:	c8 2f       	mov	r28, r24
    SD_read(sd_sector, sd_pos, fat16_buffer, bytes);
 568:	e8 2e       	mov	r14, r24
 56a:	ff 24       	eor	r15, r15
 56c:	60 91 6a 00 	lds	r22, 0x006A
 570:	70 91 6b 00 	lds	r23, 0x006B
 574:	80 91 6c 00 	lds	r24, 0x006C
 578:	90 91 6d 00 	lds	r25, 0x006D
 57c:	40 91 8e 00 	lds	r20, 0x008E
 580:	50 91 8f 00 	lds	r21, 0x008F
 584:	2e e6       	ldi	r18, 0x6E	; 110
 586:	30 e0       	ldi	r19, 0x00	; 0
 588:	87 01       	movw	r16, r14
 58a:	51 df       	rcall	.-350    	; 0x42e <SD_read>
    sd_pos+=(unsigned short)bytes;
 58c:	80 91 8e 00 	lds	r24, 0x008E
 590:	90 91 8f 00 	lds	r25, 0x008F
 594:	8e 0d       	add	r24, r14
 596:	9f 1d       	adc	r25, r15
 598:	90 93 8f 00 	sts	0x008F, r25
 59c:	80 93 8e 00 	sts	0x008E, r24
    
    if(sd_pos == 512) {
 5a0:	22 e0       	ldi	r18, 0x02	; 2
 5a2:	80 30       	cpi	r24, 0x00	; 0
 5a4:	92 07       	cpc	r25, r18
 5a6:	b9 f4       	brne	.+46     	; 0x5d6 <fat16_read+0x7a>
        sd_pos = 0;
 5a8:	10 92 8f 00 	sts	0x008F, r1
 5ac:	10 92 8e 00 	sts	0x008E, r1
        sd_sector++;
 5b0:	80 91 6a 00 	lds	r24, 0x006A
 5b4:	90 91 6b 00 	lds	r25, 0x006B
 5b8:	a0 91 6c 00 	lds	r26, 0x006C
 5bc:	b0 91 6d 00 	lds	r27, 0x006D
 5c0:	01 96       	adiw	r24, 0x01	; 1
 5c2:	a1 1d       	adc	r26, r1
 5c4:	b1 1d       	adc	r27, r1
 5c6:	80 93 6a 00 	sts	0x006A, r24
 5ca:	90 93 6b 00 	sts	0x006B, r25
 5ce:	a0 93 6c 00 	sts	0x006C, r26
 5d2:	b0 93 6d 00 	sts	0x006D, r27
    }
    
    return bytes;
}
 5d6:	8c 2f       	mov	r24, r28
 5d8:	cf 91       	pop	r28
 5da:	1f 91       	pop	r17
 5dc:	0f 91       	pop	r16
 5de:	ff 90       	pop	r15
 5e0:	ef 90       	pop	r14
 5e2:	08 95       	ret

000005e4 <_exit>:
 5e4:	f8 94       	cli

000005e6 <__stop_program>:
 5e6:	ff cf       	rjmp	.-2      	; 0x5e6 <__stop_program>
